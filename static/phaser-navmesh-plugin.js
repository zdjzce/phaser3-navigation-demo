!function(t,s){"object"==typeof exports&&"object"==typeof module?module.exports=s(require("phaser")):"function"==typeof define&&define.amd?define(["phaser"],s):"object"==typeof exports?exports.PhaserNavMeshPlugin=s(require("phaser")):t.PhaserNavMeshPlugin=s(t.Phaser)}(self,(function(t){return(()=>{var s={774:(t,s)=>{var e,n,i,o;o=function(){function t(t){for(var s=t,e=[];s.parent;)e.unshift(s),s=s.parent;return e}var s={search:function(e,n,o,r){e.cleanDirty();var h=(r=r||{}).heuristic||s.heuristics.manhattan,a=r.closest||!1,l=new i((function(t){return t.f})),c=n;for(n.h=h(n,o),e.markDirty(n),l.push(n);l.size()>0;){var u=l.pop();if(u===o)return t(u);u.closed=!0;for(var p=e.neighbors(u),d=0,f=p.length;d<f;++d){var g=p[d];if(!g.closed&&!g.isWall()){var y=u.g+g.getCost(u),b=g.visited;(!b||y<g.g)&&(g.visited=!0,g.parent=u,g.h=g.h||h(g,o),g.g=y,g.f=g.g+g.h,e.markDirty(g),a&&(g.h<c.h||g.h===c.h&&g.g<c.g)&&(c=g),b?l.rescoreElement(g):l.push(g))}}}return a?t(c):[]},heuristics:{manhattan:function(t,s){return Math.abs(s.x-t.x)+Math.abs(s.y-t.y)},diagonal:function(t,s){var e=Math.sqrt(2),n=Math.abs(s.x-t.x),i=Math.abs(s.y-t.y);return 1*(n+i)+(e-2)*Math.min(n,i)}},cleanNode:function(t){t.f=0,t.g=0,t.h=0,t.visited=!1,t.closed=!1,t.parent=null}};function e(t,s){s=s||{},this.nodes=[],this.diagonal=!!s.diagonal,this.grid=[];for(var e=0;e<t.length;e++){this.grid[e]=[];for(var i=0,o=t[e];i<o.length;i++){var r=new n(e,i,o[i]);this.grid[e][i]=r,this.nodes.push(r)}}this.init()}function n(t,s,e){this.x=t,this.y=s,this.weight=e}function i(t){this.content=[],this.scoreFunction=t}return e.prototype.init=function(){this.dirtyNodes=[];for(var t=0;t<this.nodes.length;t++)s.cleanNode(this.nodes[t])},e.prototype.cleanDirty=function(){for(var t=0;t<this.dirtyNodes.length;t++)s.cleanNode(this.dirtyNodes[t]);this.dirtyNodes=[]},e.prototype.markDirty=function(t){this.dirtyNodes.push(t)},e.prototype.neighbors=function(t){var s=[],e=t.x,n=t.y,i=this.grid;return i[e-1]&&i[e-1][n]&&s.push(i[e-1][n]),i[e+1]&&i[e+1][n]&&s.push(i[e+1][n]),i[e]&&i[e][n-1]&&s.push(i[e][n-1]),i[e]&&i[e][n+1]&&s.push(i[e][n+1]),this.diagonal&&(i[e-1]&&i[e-1][n-1]&&s.push(i[e-1][n-1]),i[e+1]&&i[e+1][n-1]&&s.push(i[e+1][n-1]),i[e-1]&&i[e-1][n+1]&&s.push(i[e-1][n+1]),i[e+1]&&i[e+1][n+1]&&s.push(i[e+1][n+1])),s},e.prototype.toString=function(){for(var t=[],s=this.grid,e=0;e<s.length;e++){for(var n=[],i=s[e],o=0;o<i.length;o++)n.push(i[o].weight);t.push(n.join(" "))}return t.join("\n")},n.prototype.toString=function(){return"["+this.x+" "+this.y+"]"},n.prototype.getCost=function(t){return t&&t.x!=this.x&&t.y!=this.y?1.41421*this.weight:this.weight},n.prototype.isWall=function(){return 0===this.weight},i.prototype={push:function(t){this.content.push(t),this.sinkDown(this.content.length-1)},pop:function(){var t=this.content[0],s=this.content.pop();return this.content.length>0&&(this.content[0]=s,this.bubbleUp(0)),t},remove:function(t){var s=this.content.indexOf(t),e=this.content.pop();s!==this.content.length-1&&(this.content[s]=e,this.scoreFunction(e)<this.scoreFunction(t)?this.sinkDown(s):this.bubbleUp(s))},size:function(){return this.content.length},rescoreElement:function(t){this.sinkDown(this.content.indexOf(t))},sinkDown:function(t){for(var s=this.content[t];t>0;){var e=(t+1>>1)-1,n=this.content[e];if(!(this.scoreFunction(s)<this.scoreFunction(n)))break;this.content[e]=s,this.content[t]=n,t=e}},bubbleUp:function(t){for(var s=this.content.length,e=this.content[t],n=this.scoreFunction(e);;){var i,o=t+1<<1,r=o-1,h=null;if(r<s){var a=this.content[r];(i=this.scoreFunction(a))<n&&(h=r)}if(o<s){var l=this.content[o];this.scoreFunction(l)<(null===h?n:i)&&(h=o)}if(null===h)break;this.content[t]=this.content[h],this.content[h]=e,t=h}}},{astar:s,Graph:e}},"object"==typeof t.exports?t.exports=o():(n=[],void 0===(i="function"==typeof(e=o)?e.apply(void 0,n):e)||(t.exports=i))},179:(t,s,e)=>{"use strict";e.d(s,{default:()=>M});var n=e(445),i=e.n(n),o=e(774),r=e.n(o);class h{constructor(t=0,s=0){this.x=t,this.y=s}equals(t){return this.x===t.x&&this.y===t.y}angle(t){return Math.atan2(t.y-this.y,t.x-this.x)}distance(t){const s=t.x-this.x,e=t.y-this.y;return Math.sqrt(s*s+e*e)}add(t){this.x+=t.x,this.y+=t.y}subtract(t){this.x-=t.x,this.y-=t.y}clone(){return new h(this.x,this.y)}}class a{constructor(t,s){this.weight=1,this.x=0,this.y=0,this.id=t,this.polygon=s,this.edges=s.edges,this.neighbors=[],this.portals=[],this.centroid=this.calculateCentroid(),this.boundingRadius=this.calculateRadius()}getPoints(){return this.polygon.points}contains(t){return this.polygon.contains(t.x,t.y)||this.isPointOnEdge(t)}calculateCentroid(){const t=new h(0,0),s=this.polygon.points.length;return this.polygon.points.forEach((s=>t.add(s))),t.x/=s,t.y/=s,t}calculateRadius(){let t=0;for(const s of this.polygon.points){const e=this.centroid.distance(s);e>t&&(t=e)}return t}isPointOnEdge({x:t,y:s}){for(const e of this.edges)if(e.pointOnSegment(t,s))return!0;return!1}destroy(){this.neighbors=[],this.portals=[]}toString(){return`NavPoly(id: ${this.id} at: ${this.centroid})`}isWall(){return 0===this.weight}centroidDistance(t){return this.centroid.distance(t.centroid)}getCost(t){return this.centroidDistance(t)}}function l(t,s){const e=s.start,n=s.end,i=function(t,s){const e=s.x-t.x,n=s.y-t.y;return e*e+n*n}(e,n);let o=((t.x-e.x)*(n.x-e.x)+(t.y-e.y)*(n.y-e.y))/i;var r;return(r=o)<0&&(r=0),r>1&&(r=1),o=r,new h(e.x+o*(n.x-e.x),e.y+o*(n.y-e.y))}function c(t,s,e){const n=s.x-t.x,i=s.y-t.y;return(e.x-t.x)*i-n*(e.y-t.y)}function u(t,s,e=1e-4){return Math.abs(t-s)<=e}function p(t,s){let e=t-s;const n=e+Math.PI,i=2*Math.PI;return e=n-Math.floor(n/i)*i,e-=Math.PI,e}function d(t,s,e=1e-4){const n=c(t.start,t.end,s.start),i=c(t.start,t.end,s.end);return!(!u(n,0,e)||!u(i,0,e))}function f(t){return Boolean(t)}class g{constructor(){this.portals=[],this.path=[]}push(t,s){void 0===s&&(s=t),this.portals.push({left:t,right:s})}stringPull(){const t=this.portals,s=[];let e=0,n=0,i=0,o=t[0].left,r=t[0].left,h=t[0].right;s.push(o);for(var a=1;a<t.length;a++){const l=t[a].left,u=t[a].right;if(c(o,h,u)<=0){if(!(o.equals(h)||c(o,r,u)>0)){s.push(r),o=r,e=n,r=o,h=o,n=e,i=e,a=e;continue}h=u,i=a}if(c(o,r,l)>=0){if(!(o.equals(r)||c(o,h,l)<0)){s.push(h),o=h,e=i,r=o,h=o,n=e,i=e,a=e;continue}r=l,n=a}}return 0!==s.length&&s[s.length-1].equals(t[t.length-1].left)||s.push(t[t.length-1].left),this.path=s,s}}class y{constructor(t,s,e,n){this.start=new h(t,s),this.end=new h(e,n),this.left=Math.min(t,e),this.right=Math.max(t,e),this.top=Math.min(s,n),this.bottom=Math.max(s,n)}pointOnSegment(t,s){return t>=this.left&&t<=this.right&&s>=this.top&&s<=this.bottom&&this.pointOnLine(t,s)}pointOnLine(t,s){return(t-this.left)*(this.bottom-this.top)==(this.right-this.left)*(s-this.top)}}class b{constructor(t,s=!0){this.isClosed=s,this.points=t,this.edges=[];for(let s=1;s<t.length;s++){const e=t[s-1],n=t[s];this.edges.push(new y(e.x,e.y,n.x,n.y))}if(this.isClosed){const s=t[0],e=t[t.length-1];this.edges.push(new y(s.x,s.y,e.x,e.y))}}contains(t,s){let e=!1;for(let n=-1,i=this.points.length-1;++n<this.points.length;i=n){const o=this.points[n].x,r=this.points[n].y,h=this.points[i].x,a=this.points[i].y;(r<=s&&s<a||a<=s&&s<r)&&t<(h-o)*(s-r)/(a-r)+o&&(e=!e)}return e}}class x{constructor(t,s,e,n,i=0){this.key=e,this.plugin=t,this.scene=s,this.debugGraphics=null,this.navMesh=new class{constructor(t,s=0){this.meshShrinkAmount=s;const e=t.map((t=>{const s=t.map((t=>new h(t.x,t.y)));return new b(s)}));this.navPolygons=e.map(((t,s)=>new a(s,t))),this.calculateNeighbors(),this.graph=new class{constructor(t){this.grid=[],this.init=r().Graph.prototype.init.bind(this),this.cleanDirty=r().Graph.prototype.cleanDirty.bind(this),this.markDirty=r().Graph.prototype.markDirty.bind(this),this.toString=r().Graph.prototype.toString.bind(this),this.nodes=t,this.init()}neighbors(t){return t.neighbors}navHeuristic(t,s){return t.centroidDistance(s)}destroy(){this.cleanDirty(),this.nodes=[]}}(this.navPolygons)}getPolygons(){return this.navPolygons}destroy(){this.graph.destroy();for(const t of this.navPolygons)t.destroy();this.navPolygons=[]}isPointInMesh(t){return this.navPolygons.some((s=>s.contains(t)))}findClosestMeshPoint(t,s=Number.POSITIVE_INFINITY){let e=s,n=null,i=null;for(const s of this.navPolygons){if(s.contains(t)){e=0,n=s,i=t;break}const o=s.boundingRadius;if(s.centroid.distance(t)-o<e){const o=this.projectPointToPolygon(t,s);o.distance<e&&(e=o.distance,n=s,i=o.point)}}return{distance:e,polygon:n,point:i}}findPath(t,s){let e,n,i=null,o=null,a=Number.MAX_VALUE,l=Number.MAX_VALUE;const c=new h(t.x,t.y),u=new h(s.x,s.y);for(const t of this.navPolygons)n=t.boundingRadius,e=t.centroid.distance(c),e<=a&&e<=n&&t.contains(c)&&(i=t,a=e),e=t.centroid.distance(u),e<=l&&e<=n&&t.contains(u)&&(o=t,l=e);if(!o&&this.meshShrinkAmount>0)for(const t of this.navPolygons)if(n=t.boundingRadius+this.meshShrinkAmount,e=t.centroid.distance(u),e<=n){const{distance:s}=this.projectPointToPolygon(u,t);s<=this.meshShrinkAmount&&s<l&&(o=t,l=s)}if(!o)return null;if(!i&&this.meshShrinkAmount>0)for(const t of this.navPolygons)if(n=t.boundingRadius+this.meshShrinkAmount,e=t.centroid.distance(c),e<=n){const{distance:s}=this.projectPointToPolygon(c,t);s<=this.meshShrinkAmount&&s<a&&(i=t,a=s)}if(!i)return null;if(i===o)return[c,u];const p=r().astar.search(this.graph,i,o,{heuristic:this.graph.navHeuristic});if(0===p.length)return null;p.unshift(i);const d=new g;d.push(c);for(let t=0;t<p.length-1;t++){const s=p[t],e=p[t+1];let n=null;for(let t=0;t<s.neighbors.length;t++)s.neighbors[t].id===e.id&&(n=s.portals[t]);if(!n)throw new Error("Path was supposed to be found, but portal is missing!");d.push(n.start,n.end)}d.push(u),d.stringPull();let f=null;const y=[];for(const t of d.path){const s=t.clone();f&&s.equals(f)||y.push(s),f=s}return y}calculateNeighbors(){for(let t=0;t<this.navPolygons.length;t++){const s=this.navPolygons[t];for(let e=t+1;e<this.navPolygons.length;e++){const t=this.navPolygons[e];if(!(s.centroid.distance(t.centroid)>s.boundingRadius+t.boundingRadius))for(const e of s.edges)for(const n of t.edges){if(!d(e,n))continue;const i=this.getSegmentOverlap(e,n);if(!i)continue;s.neighbors.push(t),t.neighbors.push(s);const[o,r]=i;let h=s.centroid.angle(e.start),a=s.centroid.angle(i[0]),l=s.centroid.angle(i[1]),c=p(h,a),u=p(h,l);c<u?s.portals.push(new y(o.x,o.y,r.x,r.y)):s.portals.push(new y(r.x,r.y,o.x,o.y)),h=t.centroid.angle(n.start),a=t.centroid.angle(i[0]),l=t.centroid.angle(i[1]),c=p(h,a),u=p(h,l),c<u?t.portals.push(new y(o.x,o.y,r.x,r.y)):t.portals.push(new y(r.x,r.y,o.x,o.y))}}}}getSegmentOverlap(t,s){const e=[{line:t,point:t.start},{line:t,point:t.end},{line:s,point:s.start},{line:s,point:s.end}];e.sort((function(t,s){return t.point.x<s.point.x?-1:t.point.x>s.point.x?1:t.point.y<s.point.y?-1:t.point.y>s.point.y?1:0}));const n=e[0].line===e[1].line,i=e[1].point.equals(e[2].point);return n||i?null:[e[1].point,e[2].point]}projectPointToPolygon(t,s){let e=null,n=Number.MAX_VALUE;for(const i of s.edges){const s=l(t,i),o=t.distance(s);(null===e||o<n)&&(n=o,e=s)}return{point:e,distance:n}}}(n,i)}isPointInMesh(t){return this.navMesh.isPointInMesh(t)}findPath(t,s,e=i().Geom.Point){const n=this.navMesh.findPath(t,s);return n?n.map((({x:t,y:s})=>new e(t,s))):n}enableDebug(t){return t||this.debugGraphics?t&&(this.debugGraphics&&this.debugGraphics.destroy(),this.debugGraphics=t):this.debugGraphics=this.scene.add.graphics(),this.debugGraphics.visible=!0,this.debugGraphics}disableDebug(){this.debugGraphics&&(this.debugGraphics.visible=!1)}isDebugEnabled(){return this.debugGraphics&&this.debugGraphics.visible}debugDrawClear(){this.debugGraphics&&this.debugGraphics.clear()}debugDrawMesh({drawCentroid:t=!0,drawBounds:s=!1,drawNeighbors:e=!0,drawPortals:n=!0,palette:i=[41136,6965820,13382463,15427649,15583569]}={}){if(!this.debugGraphics)return;const o=this.debugGraphics;this.navMesh.getPolygons().forEach((r=>{const h=i[r.id%i.length];o.fillStyle(h),o.fillPoints(r.getPoints(),!0),t&&(o.fillStyle(0),o.fillCircle(r.centroid.x,r.centroid.y,4)),s&&(o.lineStyle(1,16777215),o.strokeCircle(r.centroid.x,r.centroid.y,r.boundingRadius)),e&&(o.lineStyle(2,0),r.neighbors.forEach((t=>{o.lineBetween(r.centroid.x,r.centroid.y,t.centroid.x,t.centroid.y)}))),n&&(o.lineStyle(10,0),r.portals.forEach((t=>o.lineBetween(t.start.x,t.start.y,t.end.x,t.end.y))))}))}debugDrawPath(t,s=65280,e=10,n=1){if(this.debugGraphics&&t&&t.length){this.debugGraphics.lineStyle(e,s,n),this.debugGraphics.strokePoints(t),this.debugGraphics.fillStyle(s,n);const i=1.2*e;if(this.debugGraphics.fillCircle(t[0].x,t[0].y,i),t.length>1){const s=t[t.length-1];this.debugGraphics.fillCircle(s.x,s.y,i)}}}destroy(){this.navMesh&&this.navMesh.destroy(),this.debugGraphics&&this.debugGraphics.destroy(),this.plugin.removeMesh(this.key)}}class v{constructor(){this.data=[]}add(t){this.data.push(t)}shift(){return this.data.shift()}isEmpty(){return 0===this.data.length}containsPoint(t){return void 0!==this.data.find((s=>s.x===t.x&&s.y===t.y))}containsAllPoints(t){return t.every((t=>this.containsPoint(t)))}getIndexOfPoint(t){return this.data.findIndex((s=>s.x==t.x&&s.y==t.y))}removePoint(t){const s=this.getIndexOfPoint(t);-1!==s&&this.data.splice(s,1)}removePoints(t){t.forEach((t=>this.removePoint(t)))}}class m{constructor(t,s,e,n){this.left=t,this.right=e,this.top=s,this.bottom=n,this.tiles=[]}forEachTopPoint(t){for(let s=this.left;s<=this.right;s++)t(s,this.top)}forEachBottomPoint(t){for(let s=this.left;s<=this.right;s++)t(s,this.bottom)}forEachLeftPoint(t){for(let s=this.top;s<=this.bottom;s++)t(this.left,s)}forEachRightPoint(t){for(let s=this.top;s<=this.bottom;s++)t(this.right,s)}}function P(t,s=1,e=1,n=f){const i=new v,o=[];let r;t.forEach(((t,s)=>{t.forEach(((t,e)=>{n(t,e,s)&&i.add({x:e,y:s})}))}));const h=(t,s)=>{const e=((t,s)=>{const e=[];if("top"===s)t.forEachTopPoint(((t,s)=>e.push({x:t,y:s-1})));else if("bottom"===s)t.forEachBottomPoint(((t,s)=>e.push({x:t,y:s+1})));else if("left"===s)t.forEachLeftPoint(((t,s)=>e.push({x:t-1,y:s})));else{if("right"!==s)throw new Error(`Invalid dir "${s}" for extend`);t.forEachRightPoint(((t,s)=>e.push({x:t+1,y:s})))}return e})(t,s),n=i.containsAllPoints(e);return n&&(((t,s)=>{if("top"===s)t.top-=1;else if("bottom"===s)t.bottom+=1;else if("left"===s)t.left-=1;else{if("right"!==s)throw new Error(`Invalid dir "${s}" for extend`);t.right+=1}})(t,s),t.tiles.push(...e),i.removePoints(e)),n};for(;!i.isEmpty();){const t=i.shift();if(void 0===t)break;r=new m(0,0,0,0),r.left=t.x,r.right=t.x,r.top=t.y,r.bottom=t.y,r.tiles.push(t);let s=!0;for(;s;){const t=h(r,"top"),e=h(r,"bottom"),n=h(r,"left"),i=h(r,"right");s=t||e||n||i}o.push(r)}return o.map((t=>{const n=t.left*s,i=t.top*e,o=(t.right+1)*s,r=(t.bottom+1)*e;return[{x:n,y:i},{x:n,y:r},{x:o,y:r},{x:o,y:i}]}))}class w extends i().Plugins.ScenePlugin{constructor(t,s){super(t,s),this.phaserNavMeshes={}}boot(){this.systems.events.once("destroy",this.destroy,this)}init(){}start(){}destroy(){this.systems.events.off("boot",this.boot,this),this.removeAllMeshes()}removeAllMeshes(){const t=Object.values(this.phaserNavMeshes);this.phaserNavMeshes={},t.forEach((t=>t.destroy()))}removeMesh(t){this.phaserNavMeshes[t]&&delete this.phaserNavMeshes[t]}buildMeshFromTilemap(t,s,e,n){const i=e?e.map((t=>t.layer)):s.layers;n||(n=t=>!t.collides);let o=0,r=0,h=1,a=1;if(e){const t=e[0];o=t.tileToWorldX(0),r=t.tileToWorldY(0),h=t.scaleX,a=t.scaleY;for(const t of e)o===t.tileToWorldX(0)&&r===t.tileToWorldY(0)&&h===t.scaleX&&a===t.scaleY||console.warn(`PhaserNavMeshPlugin: buildMeshFromTilemap reads position & scale from the 1st TilemapLayer. Layer index ${t.layerIndex} has a different position & scale from the 1st TilemapLayer.`),0!==t.rotation&&console.warn(`PhaserNavMeshPlugin: buildMeshFromTilemap doesn't support TilemapLayer with rotation. Layer index ${t.layerIndex} is rotated.`)}i.forEach((t=>{0===t.x&&0===t.y||console.warn("PhaserNavMeshPlugin: buildMeshFromTilemap doesn't support layers with x/y positions from Tiled.")}));const l=[];for(let t=0;t<s.height;t+=1){const e=[];for(let o=0;o<s.width;o+=1){let s=!0;for(const e of i){const i=e.data[t][o];if(i&&!n(i)){s=!1;break}}e.push(s)}l.push(e)}let c=P(l,s.tileWidth,s.tileHeight);1!==h&&1!==a&&0!==o&&0!==r&&(c=c.map((t=>t.map((t=>({x:t.x*h+o,y:t.y*a+r}))))));const u=new x(this,this.scene,t,c,0);return this.phaserNavMeshes[t]=u,u}buildMeshFromTiled(t,s,e=0){if(this.phaserNavMeshes[t])return console.warn(`NavMeshPlugin: a navmesh already exists with the given key: ${t}`),this.phaserNavMeshes[t];s&&0!==s.objects.length||console.warn(`NavMeshPlugin: The given tilemap object layer is empty or undefined: ${s}`);const n=(s.objects??[]).map((t=>{const s=t.height??0,e=t.width??0,n=t.x??0,i=t.y??0,o=i+s,r=n+e;return[{x:n,y:i},{x:n,y:o},{x:r,y:o},{x:r,y:i}]})),i=new x(this,this.scene,t,n,e);return console.log(n.length),this.phaserNavMeshes[t]=i,i}}const M=w},445:s=>{"use strict";s.exports=t}},e={};function n(t){if(e[t])return e[t].exports;var i=e[t]={exports:{}};return s[t](i,i.exports,n),i.exports}return n.n=t=>{var s=t&&t.__esModule?()=>t.default:()=>t;return n.d(s,{a:s}),s},n.d=(t,s)=>{for(var e in s)n.o(s,e)&&!n.o(t,e)&&Object.defineProperty(t,e,{enumerable:!0,get:s[e]})},n.o=(t,s)=>Object.prototype.hasOwnProperty.call(t,s),n(179)})().default}));
//# sourceMappingURL=phaser-navmesh-plugin.js.map